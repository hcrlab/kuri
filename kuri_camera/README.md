# kuri_camera

This package provides multiple nodes for working with Kuri's camera, depending on your needs. Refer here for more information about madmux: https://github.com/KuriRobot/Kuri-Documentation/blob/master/reference/ros-packages/madmux.md

## Dependencies

- OpenCV
- libav: `apt-get install libav-tools` (you can also maybe install it by installing FFMPEG or through https://libav.org/)

## Nodes

### Python

- `ros_publisher.py` is the simplest to use and slowest node in this package. It registers a callback from madmux's MJPEG stream, converts the images into CompressedImage rosmsgs, and then publishes them.

### C++

- NOTE: For the C++ code to compile, you have to manually link to `libmadmux` and multiple other libraries. This requires finding the paths to these libraries. The CMake file contains the paths to those libraries on **our** computers -- use those as pointers to find those libraries on **your** computers, andthen change the paths accordingly.
- `ros_publisher` is the second-simplest and second-slowest node to use. This does the same thing as `ros_publisher.py`, except in C++.
- The fastest way to receive images is to use H264 compression (which compresses the image in space and time, as opposed to the `ros_publisher`s which only compress them in space). Our approach involves porting the Unix Domain Socket (UDS) data stream published by Kuri's camera directly to a TCP socket, and then reading from that TCP socket on a remote computer and processing the images.
  - NOTE: as all these nodes require that the tcp socket hostname and port be given as params, it is recommended to run these nodes through the launchfiles of the same name, as opposed to through rosrun.
  - `uds_to_tcp` is the node that reads bytes from the UDS socket and ports them over to a TCP socket. This must be run **on the Kuri**.
  - `tcp_test_client` is just a test client you can run to ensure that data is getting streamed to the TCP socket as expected. It will partition the stream into H264 frames and print the size and beginning bytes of each frame.
  - `h264_decoder_node` subscribes to the TCP socket, decodes the H264 stream, and converts the image to a cv::Mat. The current code then displays it using OpenCV's imshow and publishes it as a ros Image msg -- however, there is a sample function demonstrating how to use the cv::Mat for arbitrary processing, while remaining thread-safe. This node should be run **on a remote computer**. (NOTE: if you would like to use the H264 stream but process images on-board the Kuri, we recommend you change `h264_decoder.cpp` to read directly from the UDS socket, instead of the TCP socket that is generated by `uds_to_TCP`).
- NOTE: Since we use TCP socket connections, only one remote computer can run the `h264_decoder_node` at a time. If you need multiple remote computers to access Kuri's images, we would recommend modifying uds_to_tcp to publish the same data on two TCP sockets.

### Miscellaneous
- `display_compressed_images` will read a CompressedImage rosmsg, display it, and print out the delay between when the message was received and the timestamp on the message. This can be used in conjunction with the `ros_publisher` nodes.

## Latency Analysis
- To determine **end-to-end latency**, we set up a computer near our remote computer and ran a stopwatch on it. This was our ground truth. We then pointed the Kuri's camera at this computer and used the above node(s) to display Kuri's image on the remote computer. We then took a video of the ground truth computer and the adjacent remote computer. We then played back the video and paused it at certain frames. The difference is the end-to-end latency. We have seen it as low as 300-400 ms when just displaying the cv::Mat (it goes to 400-500 ms when also publishing a ros Image msg).
- Note that for the h264 setup, end-to-end latency is the sum of multiple latencies:
    1) the latency from when Kuri's camera sees the image to when it is written to the UDS socket;
    2) the latency from when it is written to the UDS socket to when it is read from the UDS socket;
    3) the latency from when we read it from the UDS socket and write it to the TCP socket;
    4) the latency from when we write it to the TCP socket on the Kuri to when we read it from the TCP socket on the remote computer (network latency);
    5) the latency from when we read it from the TCP socket to when we convert it into a cv::Mat (processing latency);
    6) the latency from when we have a cv::Mat to when the cv::Mat is rendered (rendering latency, which is dependent on the processing capabilities of your remote machine).
- Of these, latencies 1-3 are likely very low, so we do not measure them. Latencies 4-6 are likely the bottleneck. Below, we have instructions for measuring 4 and 5 independently. Approximately speaking, 6 will be the difference between the end-to-end latency and the sum of 4 and 5.
- To investigate **network latency**, make sure both the Kuri and the remote computer have a time synchronization program such as chronyc running. Then, uncomment the lines in uds_to_TCP.cpp (roughly lines 47-66) and in h264_decoder.cpp (roughly line 308-310). Now, when you run it, for every received H264 frame both the Kuri and the remote computer will print out the timestep they sent/received it at. The difference is network latency. Of course it depends on the network, but we got this to be as low as 3 ms.
- To investigate **processing latency**, comment out the lines in h264_decoder_node.cpp (roughly lines 60-63). We got as low as 5 ms.

## Notes
- This package includes camera configuration parameters that work for our Kuri. We do not provide guarantees that the same calibration parameters will work for other Kuri's. If your camera work requires a perfectly calibrated camera, we recommend you follow [ROS's monocular camera calibration tutorial](http://wiki.ros.org/camera_calibration/Tutorials/MonocularCalibration) and replace the parameters in config/camera_Calibration_parameters.yaml.
- Sometimes while making the package you will get a warning due to a cycle in the constraint graph. Ignore that -- the code compiles properly despite that.
